import { VersionWorkerImpl } from './worker';
import { ScopedCache } from './cache';
import { readLog, Verbosity } from './logging';
import { parseManifest } from './manifest';
import { doAsync } from './rxjs';
import { Observable } from 'rxjs/Observable';
export var Driver = (function () {
    function Driver(manifestUrl, plugins, scope, adapter, cache, events, fetcher) {
        var _this = this;
        this.manifestUrl = manifestUrl;
        this.plugins = plugins;
        this.scope = scope;
        this.adapter = adapter;
        this.cache = cache;
        this.events = events;
        this.fetcher = fetcher;
        this.active = Promise.resolve(null);
        this.installing = Promise.resolve(null);
        this.cacheActive = new ScopedCache(cache, 'meta:active:');
        this.cacheInstalled = new ScopedCache(cache, 'meta:installed:');
        this.active = this.maybeCreateWorker(this.fetchManifestFromCache(this.cacheActive));
        this.installing = this.maybeCreateWorker(this.fetchManifestFromCache(this.cacheInstalled));
        events.install.subscribe(function (event) {
            var worker = _this.maybeCreateWorker(_this.fetchManifestFromNetwork());
            _this.installing = Promise
                .all([worker, _this.active])
                .then(function (results) {
                var worker = results[0], active = results[1];
                var setup = worker
                    .setup(active)
                    .ignoreElements();
                return Observable
                    .concat(setup, Observable.of(worker))
                    .let(doAsync(function (worker) {
                    return _this.cacheInstalled.store('ngsw', _this.manifestUrl, _this.adapter.newResponse(worker.manifest._json));
                }))
                    .toPromise();
            });
            event.waitUntil(_this.installing);
        });
        events.activate.subscribe(function (event) {
            _this.active = _this
                .active
                .then(function (worker) {
                var cleanupOps = [];
                if (worker) {
                    cleanupOps.push.apply(cleanupOps, worker.cleanup());
                }
                return Observable
                    .from(cleanupOps)
                    .concatMap(function (op) { return op(); })
                    .ignoreElements()
                    .concat(_this.installing)
                    .toPromise();
            })
                .then(function (worker) {
                if (!worker) {
                    throw 'Activate without a worker in installed state?';
                }
                return _this.cacheActive.store('ngsw', _this.manifestUrl, _this.adapter.newResponse(worker.manifest._json))
                    .toPromise()
                    .then(function () { return worker; });
            });
            event.waitUntil(_this.active);
        });
        events.fetch.subscribe(function (event) {
            var result = _this
                .active
                .then(function (worker) {
                if (worker === null) {
                    return _this
                        .fetcher
                        .request(event.request)
                        .toPromise();
                }
                return worker
                    .fetch(event.request)
                    .toPromise();
            });
            event.respondWith(result);
        });
        events
            .message
            .filter(function (event) {
            return event.ports.length === 1 &&
                event.data &&
                event.data.hasOwnProperty('$ngsw');
        })
            .do(function (event) { return console.log('GOT EVENT', event.data); })
            .flatMap(function (event) {
            var respond = event.ports[0];
            return _this
                .handleMessage(event.data)
                .do(function (resp) { return console.log('EVENT RESP', resp); }, function (err) { return console.log('ERROR', err); }, function () { return console.log('EVENT DONE'); })
                .do(function (response) { return respond.postMessage(response); }, undefined, function () { return respond.postMessage(null); })
                .ignoreElements();
        })
            .subscribe();
        events
            .push
            .filter(function (event) { return !!event.data; })
            .map(function (event) { return event.data.json(); })
            .subscribe(function (data) {
            _this
                .active
                .then(function (worker) { return worker && worker.push(data); });
        });
    }
    Driver.prototype.fetchManifestFromNetwork = function () {
        return this
            .fetcher
            .refresh(this.manifestUrl)
            .map(function (v) { return v && v.status === 200 ? v : null; })
            .switchMap(function (v) { return v ? v.text() : Observable.of(null); })
            .map(function (v) { return v ? parseManifest(v) : null; });
    };
    Driver.prototype.fetchManifestFromCache = function (cache) {
        return cache
            .load('ngsw', this.manifestUrl)
            .switchMap(function (v) { return v ? v.text() : Observable.of(null); })
            .map(function (v) { return v ? parseManifest(v) : null; });
    };
    Driver.prototype.fetchStartupManifest = function () {
        return Observable
            .concat(this.fetchManifestFromCache(this.cacheActive), this.fetchManifestFromNetwork())
            .first();
    };
    Driver.prototype.maybeCreateWorker = function (manifest) {
        var _this = this;
        return manifest
            .map(function (manifest) {
            if (!manifest) {
                return null;
            }
            var cache = new ScopedCache(_this.cache, "version:" + manifest._hash + ":");
            var plugins = [];
            var worker = new VersionWorkerImpl(_this.scope, manifest, _this.adapter, cache, _this.fetcher, plugins);
            plugins.push.apply(plugins, _this
                .plugins
                .map(function (factory) { return factory(worker); }));
            return worker;
        })
            .toPromise();
    };
    Driver.prototype.handleMessage = function (message) {
        switch (message['cmd']) {
            case 'ping':
                return Observable.empty();
            case 'log':
                var level = Verbosity.DETAIL;
                return readLog(level);
            default:
                return Observable
                    .fromPromise(this.active)
                    .switchMap(function (active) { return active
                    ? active.message(message)
                    : Observable.empty(); })
                    .switchMap(function (op) { return op(); });
        }
    };
    return Driver;
}());
//# sourceMappingURL=driver.js.map
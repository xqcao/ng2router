(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('rxjs/add/observable/concat'), require('rxjs/add/observable/empty'), require('rxjs/add/observable/fromEvent'), require('rxjs/add/observable/merge'), require('rxjs/add/observable/of'), require('rxjs/add/observable/timer'), require('rxjs/add/operator/cache'), require('rxjs/add/operator/concatMap'), require('rxjs/add/operator/filter'), require('rxjs/add/operator/first'), require('rxjs/add/operator/mergeMap'), require('rxjs/add/operator/map'), require('rxjs/add/operator/reduce'), require('rxjs/add/operator/switchMap'), require('rxjs/add/operator/publishReplay'), require('rxjs/add/operator/take'), require('rxjs/add/operator/takeWhile'), require('@angular/core'), require('rxjs/Observable'), require('base64-js'), require('rxjs/add/observable/defer'), require('rxjs/add/observable/from'), require('rxjs/add/operator/do'), require('rxjs/add/operator/expand'), require('rxjs/add/operator/let'), require('rxjs/add/operator/share')) :
    typeof define === 'function' && define.amd ? define(['exports', 'rxjs/add/observable/concat', 'rxjs/add/observable/empty', 'rxjs/add/observable/fromEvent', 'rxjs/add/observable/merge', 'rxjs/add/observable/of', 'rxjs/add/observable/timer', 'rxjs/add/operator/cache', 'rxjs/add/operator/concatMap', 'rxjs/add/operator/filter', 'rxjs/add/operator/first', 'rxjs/add/operator/mergeMap', 'rxjs/add/operator/map', 'rxjs/add/operator/reduce', 'rxjs/add/operator/switchMap', 'rxjs/add/operator/publishReplay', 'rxjs/add/operator/take', 'rxjs/add/operator/takeWhile', '@angular/core', 'rxjs/Observable', 'base64-js', 'rxjs/add/observable/defer', 'rxjs/add/observable/from', 'rxjs/add/operator/do', 'rxjs/add/operator/expand', 'rxjs/add/operator/let', 'rxjs/add/operator/share'], factory) :
    (factory((global.ng = global.ng || {}, global.ng.serviceWorker = global.ng.serviceWorker || {}),global.Rx,global.Rx,global.Rx,global.Rx,global.Rx,global.Rx,global.Rx,global.Rx,global.Rx,global.Rx,global.Rx,global.Rx,global.Rx,global.Rx,global.Rx,global.Rx,global.Rx,global.ng.core,global.Rx,global.Base64Js,global.Rx,global.Rx,global.Rx,global.Rx,global.Rx,global.Rx));
}(this, (function (exports,rxjs_add_observable_concat,rxjs_add_observable_empty,rxjs_add_observable_fromEvent,rxjs_add_observable_merge,rxjs_add_observable_of,rxjs_add_observable_timer,rxjs_add_operator_cache,rxjs_add_operator_concatMap,rxjs_add_operator_filter,rxjs_add_operator_first,rxjs_add_operator_mergeMap,rxjs_add_operator_map,rxjs_add_operator_reduce,rxjs_add_operator_switchMap,rxjs_add_operator_publishReplay,rxjs_add_operator_take,rxjs_add_operator_takeWhile,_angular_core,rxjs_Observable,base64Js,rxjs_add_observable_defer,rxjs_add_observable_from,rxjs_add_operator_do,rxjs_add_operator_expand,rxjs_add_operator_let,rxjs_add_operator_share) { 'use strict';

function fromPromise(promiseFn) {
    return rxjs_Observable.Observable.create(function (observer) {
        promiseFn()
            .then(function (v) { return observer.next(v); })
            .then(function () { return observer.complete(); })
            .catch(function (err) { return observer.error(err); });
    });
}
// A push notification registration, including the endpoint URL and encryption keys.
var NgPushRegistration = (function () {
    function NgPushRegistration(ps) {
        this.ps = ps;
    }
    // Get the authentication key
    NgPushRegistration.prototype.auth = function () {
        return this.key('auth');
    };
    NgPushRegistration.prototype.key = function (method) {
        if (method === void 0) { method = 'p256dh'; }
        return base64Js.fromByteArray(new Uint8Array(this.ps.getKey(method)));
    };
    Object.defineProperty(NgPushRegistration.prototype, "url", {
        get: function () {
            return this.ps.endpoint;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgPushRegistration.prototype, "id", {
        get: function () {
            return this.ps.id;
        },
        enumerable: true,
        configurable: true
    });
    NgPushRegistration.prototype.unsubscribe = function () {
        var _this = this;
        // TODO: switch to Observable.fromPromise when it's not broken.
        return fromPromise(function () { return _this.ps.unsubscribe(); });
    };
    return NgPushRegistration;
}());
var NgServiceWorker = (function () {
    function NgServiceWorker(zone) {
        var _this = this;
        this.zone = zone;
        // Extract a typed version of navigator.serviceWorker.
        this.container = navigator['serviceWorker'];
        // Final Observable that will always give back the current controlling worker,
        // and follow changes over time.
        this.controllingWorker = rxjs_Observable.Observable
            .concat(
        // Current controlling worker (if any).
        rxjs_Observable.Observable.of(this.container.controller), 
        // Future changes of the controlling worker.
        rxjs_Observable.Observable
            .fromEvent(this.container, 'controllerchange')
            .map(function (_) { return _this.container.controller; }))
            .cache(1);
        // To make one-off calls to the worker, awaitSingleControllingWorker waits for
        // a controlling worker to exist.
        this.awaitSingleControllingWorker = this
            .controllingWorker
            .filter(function (worker) { return !!worker; })
            .take(1);
        // Setup the push Observable as a broadcast mechanism for push notifications.
        this.push = rxjs_Observable.Observable
            .defer(function () { return _this.send({ cmd: 'push' }); })
            .share();
    }
    NgServiceWorker.prototype.registrationForWorker = function () {
        var _this = this;
        return function (obs) {
            return obs
                .switchMap(function (worker, index) {
                return fromPromise(function () { return _this.container.getRegistrations(); })
                    .expand(function (v) { return rxjs_Observable.Observable.from(v); })
                    .filter(function (reg) { return reg.active === worker; })
                    .take(1);
            });
        };
    };
    // Sends a single message to the worker, and awaits one (or more) responses.
    NgServiceWorker.prototype.sendToWorker = function (worker, message) {
        // A MessageChannel is sent with the message so responses can be correlated.
        var channel = new MessageChannel();
        // Observe replies.
        var result = rxjs_Observable.Observable
            .fromEvent(channel.port1, 'message')
            .map(function (event) { return event.data; })
            .takeWhile(function (v) { return !!v; })
            .publishReplay();
        // Connecting actually creates the event subscription and starts recording
        // for replay.
        result.connect();
        // Start receiving message(s).
        channel.port1.start();
        // Set a magic value in the message.
        message['$ngsw'] = true;
        worker.postMessage(message, [channel.port2]);
        return result;
    };
    // Send a message to the current controlling worker, waiting for one if needed.
    NgServiceWorker.prototype.send = function (message) {
        var _this = this;
        return this
            .awaitSingleControllingWorker
            .switchMap(function (worker) { return _this.sendToWorker(worker, message); });
    };
    // Send a 'ping' to the worker. The returned Observable will complete when the worker
    // acknowledges the message. This provides a test that the worker is alive and listening.
    NgServiceWorker.prototype.ping = function () {
        return this.send({
            cmd: 'ping'
        });
    };
    NgServiceWorker.prototype.log = function () {
        return this.send({
            cmd: 'log'
        });
    };
    NgServiceWorker.prototype.registerForPush = function () {
        var _this = this;
        return this
            .awaitSingleControllingWorker
            .let(this.registrationForWorker())
            .map(function (worker) { return worker.pushManager; })
            .switchMap(function (pushManager) {
            // Create an Observable to wrap the Promises of the PushManager API.
            // TODO: switch to Observable.fromPromise when it's not broken.
            // This is extracted as a variable so Typescript infers types correctly.
            var reg = rxjs_Observable.Observable.create(function (observer) {
                // Function that maps subscriptions to an Angular-specific representation.
                var regFromSub = function (sub) { return new NgPushRegistration(sub); };
                pushManager
                    .getSubscription()
                    .then(function (sub) {
                    // If there is one, we don't need to register, just return it.
                    if (!!sub) {
                        return regFromSub(sub);
                    }
                    // No existing subscription, register (with userVisibleOnly: true).
                    return pushManager
                        .subscribe({ userVisibleOnly: true })
                        .then(regFromSub);
                })
                    .then(function (sub) { return _this.zone.run(function () { return observer.next(sub); }); })
                    .then(function () { return _this.zone.run(function () { return observer.complete(); }); })
                    .catch(function (err) { return _this.zone.run(function () { return observer.error(err); }); });
            });
            return reg;
        });
    };
    NgServiceWorker.decorators = [
        { type: _angular_core.Injectable },
    ];
    /** @nocollapse */
    NgServiceWorker.ctorParameters = [
        { type: _angular_core.NgZone, },
    ];
    return NgServiceWorker;
}());

var ServiceWorkerModule = (function () {
    function ServiceWorkerModule() {
    }
    ServiceWorkerModule.decorators = [
        { type: _angular_core.NgModule, args: [{
                    providers: [NgServiceWorker],
                },] },
    ];
    /** @nocollapse */
    ServiceWorkerModule.ctorParameters = [];
    return ServiceWorkerModule;
}());

exports.NgServiceWorker = NgServiceWorker;
exports.NgPushRegistration = NgPushRegistration;
exports.ServiceWorkerModule = ServiceWorkerModule;

Object.defineProperty(exports, '__esModule', { value: true });

})));